## 三次握手四次挥手
- https://blog.csdn.net/dreamispossible/article/details/91345391
- https://blog.csdn.net/qq_25948717/article/details/80382766

### 三次握手的过程
- 刚开始客户端处于 closed 的状态，服务端处于 listen 状态。然后
1. 第一次握手：客户端给服务端发一个 SYN 报文，并指明客户端的初始化序列号 ISN（c）。此时客户端处于 SYN_Send 状态。
2. 第二次握手：服务端收到客户端的 SYN 报文之后，以自己的 SYN 报文作为应答，并且指定自己的初始化序列号 ISN(s)，同时把客户端的 ISN + 1 作为 ACK 的值，表示自己已经收到客户端的 SYN，此时服务端处于 SYN_REVD 的状态。
3. 第三次握手：客户端收到 SYN 报文后，把服务端的 ISN + 1 作为 ACK 的值，发送一个 ACK 报文，表示已经收到了服务端的 SYN 报文，此时客户端处于 establised 状态。
4. 服务端收到 ACK 报文之后，也处于 establised 状态，此时，双方建立起链接。
- 位码即tcp标志位，有6种标示：SYN(synchronous建立联机) ACK(acknowledgement 确认) PSH(push传送) FIN(finish结束) RST(reset重置) URG(urgent紧急)Sequence number(顺序号码) Acknowledge number(确认号码)

### 三次握手的作用
- 确认双方的接受能力、发送能力是否正常。
- 指定自己的初始化序列号，为后面的可靠传送做准备。
- 如果是 https 协议的话，三次握手这个过程，还会进行数字证书的验证以及加密密钥的生成。

### 四次挥手的过程
- 刚开始双方都处于 establised 状态，假如是客户端先发起关闭请求，则：
1. 第一次挥手：客户端发送一个 FIN 报文，报文中会指定一个序列号。此时客户端处于FIN_WAIT1状态。
2. 第二次挥手：服务端收到 FIN 之后，会发送 ACK 报文，且把客户端的序列号值 + 1 作为 ACK 报文的序列号值，表明已经收到客户端的报文了，此时服务端处于 CLOSE_WAIT状态。
3. 第三次挥手：如果服务端也想断开连接，会发送一个 FIN 报文，且指定一个序列号。此时服务端处于 LAST_ACK 的状态。
4. 第四次挥手：客户端收到 FIN 之后，发送一个 ACK 报文作为应答，且把服务端的序列号值 + 1 作为自己 ACK 报文的序列号值，此时客户端处于 TIME_WAIT 状态。需要过一阵子以确保服务端收到自己的 ACK 报文之后才会进入 CLOSED 状态
5. 服务端收到 ACK 报文之后，进入 CLOSED 状态，关闭连接。

### tcp第四次挥手断开连接为什么需要TIME_WAIT状态？
- https://blog.csdn.net/n1neding/article/details/83415695
- 主动关闭的那端会进入这种状态，停留在TIME_WAIT的时间是最长分节生命期MSL(maximum segment lifetime)的两倍，成为2MSL。
- 存在TIME_WAIT状态有两个理由：
1. 实现终止tcp全双工连接的可靠性
    - 当最终的ACK丢失，服务器将重发FIN，因此客户端需要维护状态信息以允许它重发最终的ACK。所以需要TIME_WAIT存在以重发丢失的ack，而不是直接关闭。
2. 允许老的重复分组在网络中消逝
    - 重复分组除了超时重传的分组外，还有一种成为迷途的重复分组：假如某个路由跟之后的路由间链路突然断开，路由协议需要一段时间才能够稳定并找到另一条通路，在这段时间可能产生路由循环（路由器A把tcp分组发送给路由器B，路由器B再把分组重新发给A，因为没有别的通路），迷途分组最多存在MSL时间，如果在这个时间内路由循环修复，那么这个迷途分组也会最终到达目的地。

    - 考虑这种情况，如果一个ip地址的某端口和另外一个ip地址的某端口建立了一个tcp连接，如果关闭之后短时间内再次重新建立完全相同的ip地址和对应端口的连接，这个时候便需要考虑上次连接时存在的老重复分组再次发挥作用。为避免这种情况，便需要2个MSL的TIME_WAIT，之所以为两个，首先足够某个方向上的分组最多存活MSL即被丢弃，另一个方向上的应答最多存活MSL也被丢弃，通过两个MSL，能保证当成功建立一个TCP连接时，来自该连接之前的老重复分组都已在网络中消逝。

### 为什么第二次挥手不需要time_wait
- https://www.zhihu.com/question/333281372
- 所有的 TCP segment 都自带一个字段叫 Ack Number，所以只要不是最后一个 ACK 包，其余的包都能得到确认。
- 被动关闭端不是没有等，而是在一直等，这个状态是LAST-ACK，没有等到就一直等。



