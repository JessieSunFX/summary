## 防抖和节流:不希望在事件持续触发的过程中那么频繁地去执行函数。

## 防抖（debounce）
1. 不管事件触发频率多高，一定在事件触发n秒后才执行
2. 如果在一个事件触发的n秒内又触发了这个事件，就以新的事件的事件为准，n秒后才执行
3. 总之，触发完事件n秒内不再触发事件，n秒后再执行

### 思路
1. 返回一个函数
2. 每次触发事件时都取消之前的定时器

### 需要注意的问题
1. this指向
2. 参数的传递
3. 是否要立即调用一次 

```
function debounce(fn, wait, immediate) {
    let timer = null
    // 返回一个函数
    return function(...args) {
        // 每次触发事件时都取消之前的定时器
        if(timer) clearTimeout(timer)
        // 判断是否要立即执行一次
        if(immediate && !timer) {
            fn.apply(this, args)
        }
        // setTimeout中使用箭头函数，就是让 this 指向 返回的该闭包函数，而不是 debounce 函数的调用者
        timer = setTimeout(() => {
            fn.apply(this, args)
        }, wait)
    }
}
```

### 双剑合璧版
```
/**
 * @desc 防抖函数
 * @param func 函数
 * @param wait 延迟执行毫秒数
 * @param immediate true 表示立即执行， false 表示非立即执行
 */
 function debounce(func, wait, immediate) {
     let timeout;

     return function() {
         let context = this;
         let args = arguments;

         if(timeout) clearTimeout(timeout);
         if(immediate) {
             let callnow = !timeout;
             timeout = setTimeout(() => {
                 timeout = null;
             }, wait)
             if(callnow) func.apply(context, args)
         } else {
             timeout = setTimeout(() => {
                 func.apply(context, args)
             }, wait);
         }
     }
 }
```

## 节流（throttle）,指连续触发事件但是在n秒中只执行一次函数。节流会稀释函数的执行频率。

### 节流分为时间戳版和定时器版。

### 时间戳版
```
function throttle(func, wait) {
    let previous = 0;
    return function() {
        let now = Date.now();
        let context = this;
        let args = arguments;
        if(now - previous > wait) {
            func.apply(context, args);
            previous = now;
        }
    }
}
```

### 定时器版
```
function throttle(func, wait) {
    let timeout;
    return function() {
        let context = this;
        let args = arguments;
        if(!timeout) {
            timeout = setTimeout(() => {
                timeout = null;
                func.apply(context, args)
            }, wait)
        }
    }
}
```

### 双剑合璧版
```
/**
 * @desc 函数节流
 * @param func 函数
 * @param wait 延迟执行毫秒数
 * @param type 1 时间戳版，2 定时器版
 */
 function throttle(func, wait, type) {
    if(type === 1) {
        let previous = 0;
    } else if(type === 2) {
        let timeout;
    }

    return function() {
        let context = this;
        let args = arguments;
        if (type === 1) {
            let now = Date.now();

            if(now - previous > wait) {
                func.apply(context, args);
                previous = now;
            }
        } else if (type === 2) {
            if(!timeout) {
                timeout = setTimeout(() => {
                    timeout = null;
                    func.apply(context, args);
                }, wait)
            }
        }
    }
 }
```