## 防抖和节流:不希望在事件持续触发的过程中那么频繁地去执行函数。一般场景用在搜索事件中。

## 防抖（debounce）,指触发事件后在n秒内函数只能执行一次，如果在n秒内又触发了事件，则会重新计算函数执行时间。

### 防抖函数分为非立即执行版和立即执行版。

### 非立即执行版
```
function debounce(func, wait) {
    let timeout;
    return function () {
        let context = this;
        let args = arguments;

        if(timeout) clearTimeout(timeout);

        timeout = setTimeout(() => {
            func.apply(context, args)
        }, wait)
    }
}
```
### 立即执行版
```
function debounce(func, wait) {
    let timeout;
    return function () {
        let context = this
        let args = arguments

        if(timeout) clearTimeout(timeout)

        let callnow = !timeout
        timeout = setTimeout(() => {
            timeout = null
        }, wait)

        if (callnow) func.applay(context, args)
    }
}
```
### 双剑合璧版
```
/**
 * @desc 防抖函数
 * @param func 函数
 * @param wait 延迟执行毫秒数
 * @param immediate true 表示立即执行， false 表示非立即执行
 */
 function debounce(func, wait, immediate) {
     let timeout;

     return function() {
         let context = this;
         let args = arguments;

         if(timeout) clearTimeout(timeout);
         if(immediate) {
             let callnow = !timeout;
             timeout = setTimeout(() => {
                 timeout = null;
             }, wait)
             if(callnow) func.apply(context, args)
         } else {
             timeout = setTimeout(() => {
                 func.apply(context, args)
             }, wait);
         }
     }
 }
```

## 节流（throttle）,指连续触发事件但是在n秒中只执行一次函数。节流会稀释函数的执行频率。

### 节流分为时间戳版和定时器版。

### 时间戳版
```
function throttle(func, wait) {
    let previous = 0;
    return function() {
        let now = Date.now();
        let context = this;
        let args = arguments;
        if(now - previous > wait) {
            func.apply(context, args);
            previous = now;
        }
    }
}
```

### 定时器版
```
function throttle(func, wait) {
    let timeout;
    return function() {
        let context = this;
        let args = arguments;
        if(!timeout) {
            timeout = setTimeout(() => {
                timeout = null;
                func.apply(context, args)
            }, wait)
        }
    }
}
```

### 双剑合璧版
```
/**
 * @desc 函数节流
 * @param func 函数
 * @param wait 延迟执行毫秒数
 * @param type 1 时间戳版，2 定时器版
 */
 function throttle(func, wait, type) {
    if(type === 1) {
        let previous = 0;
    } else if(type === 2) {
        let timeout;
    }

    return function() {
        let context = this;
        let args = arguments;
        if (type === 1) {
            let now = Date.now();

            if(now - previous > wait) {
                func.apply(context, args);
                previous = now;
            }
        } else if (type === 2) {
            if(!timeout) {
                timeout = setTimeout(() => {
                    timeout = null;
                    func.apply(context, args);
                }, wait)
            }
        }
    }
 }
```